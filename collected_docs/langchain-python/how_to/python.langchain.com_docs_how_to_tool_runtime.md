How to pass run time values to tools | ðŸ¦œï¸ðŸ”— LangChain
- **[Skip to main content](#__docusaurus_skipToContent_fallback)Our new LangChain Academy Course Deep Research with LangGraph is now live! [Enroll for free](https://academy.langchain.com/courses/deep-research-with-langgraph/?utm_medium=internal&utm_source=docs&utm_campaign=q3-2025_deep-research-course_co).[On this page![Open In Colab ](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/tool_runtime.ipynb)[![Open on GitHub ](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/tool_runtime.ipynb)How to pass run time values to tools ðŸ“šPrerequisites[Chat models](/docs/concepts/chat_models)[LangChain Tools](/docs/concepts/tools)[How to create tools](/docs/how_to/custom_tools)[How to use a model to call tools](/docs/how_to/tool_calling) ðŸ“¦CompatibilityThe code in this guide requires langchain-core>=0.2.21. Please ensure you have the correct packages installed. You may need to bind values to a [tool](/docs/concepts/tools/) that are only known at runtime. For example, the tool logic may require using the ID of the user who made the request. Most of the time, such values should not be controlled by the LLM. In fact, allowing the LLM to control the user ID may lead to a security risk. Instead, the LLM should only control the parameters of the tool that are meant to be controlled by the LLM, while other parameters (such as user ID) should be fixed by the application logic. This how-to guide shows you how to prevent the model from generating certain tool arguments and injecting them in directly at runtime. Using with LangGraphIf you&#x27;re using LangGraph, please refer to [this how-to guide](https://langchain-ai.github.io/langgraph/how-tos/pass-run-time-values-to-tools/) which shows how to create an agent that keeps track of a given user&#x27;s favorite pets. We can bind them to chat models as follows: Select [chat model](/docs/integrations/chat/):Google Geminiâ–¾[OpenAI](#)[Anthropic](#)[Azure](#)[Google Gemini](#)[Google Vertex](#)[AWS](#)[Groq](#)[Cohere](#)[NVIDIA](#)[Fireworks AI](#)[Mistral AI](#)[Together AI](#)[IBM watsonx](#)[Databricks](#)[xAI](#)[Perplexity](#)[DeepSeek](#)

```bash
pip install -qU "langchain[google-genai]"

```

```python
import getpass
import os

if not os.environ.get("GOOGLE_API_KEY"):
  os.environ["GOOGLE_API_KEY"] = getpass.getpass("Enter API key for Google Gemini: ")

from langchain.chat_models import init_chat_model

llm = init_chat_model("gemini-2.5-flash", model_provider="google_genai")

``` Hiding arguments from the model[â€‹](#hiding-arguments-from-the-model) We can use the InjectedToolArg annotation to mark certain parameters of our Tool, like user_id as being injected at runtime, meaning they shouldn&#x27;t be generated by the model

```python
from typing import List

from langchain_core.tools import InjectedToolArg, tool
from typing_extensions import Annotated

user_to_pets = {}

@tool(parse_docstring=True)
def update_favorite_pets(
    pets: List[str], user_id: Annotated[str, InjectedToolArg]
) -> None:
    """Add the list of favorite pets.

    Args:
        pets: List of favorite pets to set.
        user_id: User&#x27;s ID.
    """
    user_to_pets[user_id] = pets

@tool(parse_docstring=True)
def delete_favorite_pets(user_id: Annotated[str, InjectedToolArg]) -> None:
    """Delete the list of favorite pets.

    Args:
        user_id: User&#x27;s ID.
    """
    if user_id in user_to_pets:
        del user_to_pets[user_id]

@tool(parse_docstring=True)
def list_favorite_pets(user_id: Annotated[str, InjectedToolArg]) -> None:
    """List favorite pets if any.

    Args:
        user_id: User&#x27;s ID.
    """
    return user_to_pets.get(user_id, [])

```API Reference:**[InjectedToolArg](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.base.InjectedToolArg.html) | [tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) If we look at the input schemas for these tools, we&#x27;ll see that user_id is still listed:

```python
update_favorite_pets.get_input_schema().model_json_schema()

```**

```output
{&#x27;description&#x27;: &#x27;Add the list of favorite pets.&#x27;,
 &#x27;properties&#x27;: {&#x27;pets&#x27;: {&#x27;description&#x27;: &#x27;List of favorite pets to set.&#x27;,
   &#x27;items&#x27;: {&#x27;type&#x27;: &#x27;string&#x27;},
   &#x27;title&#x27;: &#x27;Pets&#x27;,
   &#x27;type&#x27;: &#x27;array&#x27;},
  &#x27;user_id&#x27;: {&#x27;description&#x27;: "User&#x27;s ID.",
   &#x27;title&#x27;: &#x27;User Id&#x27;,
   &#x27;type&#x27;: &#x27;string&#x27;}},
 &#x27;required&#x27;: [&#x27;pets&#x27;, &#x27;user_id&#x27;],
 &#x27;title&#x27;: &#x27;update_favorite_petsSchema&#x27;,
 &#x27;type&#x27;: &#x27;object&#x27;}

``` But if we look at the tool call schema, which is what is passed to the model for tool-calling, user_id has been removed:

```python
update_favorite_pets.tool_call_schema.model_json_schema()

```

```output
{&#x27;description&#x27;: &#x27;Add the list of favorite pets.&#x27;,
 &#x27;properties&#x27;: {&#x27;pets&#x27;: {&#x27;description&#x27;: &#x27;List of favorite pets to set.&#x27;,
   &#x27;items&#x27;: {&#x27;type&#x27;: &#x27;string&#x27;},
   &#x27;title&#x27;: &#x27;Pets&#x27;,
   &#x27;type&#x27;: &#x27;array&#x27;}},
 &#x27;required&#x27;: [&#x27;pets&#x27;],
 &#x27;title&#x27;: &#x27;update_favorite_pets&#x27;,
 &#x27;type&#x27;: &#x27;object&#x27;}

``` So when we invoke our tool, we need to pass in user_id:

```python
user_id = "123"
update_favorite_pets.invoke({"pets": ["lizard", "dog"], "user_id": user_id})
print(user_to_pets)
print(list_favorite_pets.invoke({"user_id": user_id}))

```

```output
{&#x27;123&#x27;: [&#x27;lizard&#x27;, &#x27;dog&#x27;]}
[&#x27;lizard&#x27;, &#x27;dog&#x27;]

``` But when the model calls the tool, no user_id argument will be generated:

```python
tools = [
    update_favorite_pets,
    delete_favorite_pets,
    list_favorite_pets,
]
llm_with_tools = llm.bind_tools(tools)
ai_msg = llm_with_tools.invoke("my favorite animals are cats and parrots")
ai_msg.tool_calls

```

```output
[{&#x27;name&#x27;: &#x27;update_favorite_pets&#x27;,
  &#x27;args&#x27;: {&#x27;pets&#x27;: [&#x27;cats&#x27;, &#x27;parrots&#x27;]},
  &#x27;id&#x27;: &#x27;call_pZ6XVREGh1L0BBSsiGIf1xVm&#x27;,
  &#x27;type&#x27;: &#x27;tool_call&#x27;}]

``` Injecting arguments at runtime[â€‹](#injecting-arguments-at-runtime) If we want to actually execute our tools using the model-generated tool call, we&#x27;ll need to inject the user_id ourselves:

```python
from copy import deepcopy

from langchain_core.runnables import chain

@chain
def inject_user_id(ai_msg):
    tool_calls = []
    for tool_call in ai_msg.tool_calls:
        tool_call_copy = deepcopy(tool_call)
        tool_call_copy["args"]["user_id"] = user_id
        tool_calls.append(tool_call_copy)
    return tool_calls

inject_user_id.invoke(ai_msg)

```API Reference:**[chain](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.chain.html)

```output
[{&#x27;name&#x27;: &#x27;update_favorite_pets&#x27;,
  &#x27;args&#x27;: {&#x27;pets&#x27;: [&#x27;cats&#x27;, &#x27;parrots&#x27;], &#x27;user_id&#x27;: &#x27;123&#x27;},
  &#x27;id&#x27;: &#x27;call_pZ6XVREGh1L0BBSsiGIf1xVm&#x27;,
  &#x27;type&#x27;: &#x27;tool_call&#x27;}]

```**And now we can chain together our model, injection code, and the actual tools to create a tool-executing chain:

```python
tool_map = {tool.name: tool for tool in tools}

@chain
def tool_router(tool_call):
    return tool_map[tool_call["name"]]

chain = llm_with_tools | inject_user_id | tool_router.map()
chain.invoke("my favorite animals are cats and parrots")

```

```output
[ToolMessage(content=&#x27;null&#x27;, name=&#x27;update_favorite_pets&#x27;, tool_call_id=&#x27;call_oYCD0THSedHTbwNAY3NW6uUj&#x27;)]

``` Looking at the user_to_pets dict, we can see that it&#x27;s been updated to include cats and parrots:

```python
user_to_pets

```

```output
{&#x27;123&#x27;: [&#x27;cats&#x27;, &#x27;parrots&#x27;]}

``` Other ways of annotating args[â€‹](#other-ways-of-annotating-args) Here are a few other ways of annotating our tool args:

```python
from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field

class UpdateFavoritePetsSchema(BaseModel):
    """Update list of favorite pets"""

    pets: List[str] = Field(..., description="List of favorite pets to set.")
    user_id: Annotated[str, InjectedToolArg] = Field(..., description="User&#x27;s ID.")

@tool(args_schema=UpdateFavoritePetsSchema)
def update_favorite_pets(pets, user_id):
    user_to_pets[user_id] = pets

update_favorite_pets.get_input_schema().model_json_schema()

```API Reference:**[BaseTool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.base.BaseTool.html)

```output
{&#x27;description&#x27;: &#x27;Update list of favorite pets&#x27;,
 &#x27;properties&#x27;: {&#x27;pets&#x27;: {&#x27;description&#x27;: &#x27;List of favorite pets to set.&#x27;,
   &#x27;items&#x27;: {&#x27;type&#x27;: &#x27;string&#x27;},
   &#x27;title&#x27;: &#x27;Pets&#x27;,
   &#x27;type&#x27;: &#x27;array&#x27;},
  &#x27;user_id&#x27;: {&#x27;description&#x27;: "User&#x27;s ID.",
   &#x27;title&#x27;: &#x27;User Id&#x27;,
   &#x27;type&#x27;: &#x27;string&#x27;}},
 &#x27;required&#x27;: [&#x27;pets&#x27;, &#x27;user_id&#x27;],
 &#x27;title&#x27;: &#x27;UpdateFavoritePetsSchema&#x27;,
 &#x27;type&#x27;: &#x27;object&#x27;}

```

```python
update_favorite_pets.tool_call_schema.model_json_schema()

```

```output
{&#x27;description&#x27;: &#x27;Update list of favorite pets&#x27;,
 &#x27;properties&#x27;: {&#x27;pets&#x27;: {&#x27;description&#x27;: &#x27;List of favorite pets to set.&#x27;,
   &#x27;items&#x27;: {&#x27;type&#x27;: &#x27;string&#x27;},
   &#x27;title&#x27;: &#x27;Pets&#x27;,
   &#x27;type&#x27;: &#x27;array&#x27;}},
 &#x27;required&#x27;: [&#x27;pets&#x27;],
 &#x27;title&#x27;: &#x27;update_favorite_pets&#x27;,
 &#x27;type&#x27;: &#x27;object&#x27;}

```

```python
from typing import Optional, Type

class UpdateFavoritePets(BaseTool):
    name: str = "update_favorite_pets"
    description: str = "Update list of favorite pets"
    args_schema: Optional[Type[BaseModel]] = UpdateFavoritePetsSchema

    def _run(self, pets, user_id):
        user_to_pets[user_id] = pets

UpdateFavoritePets().get_input_schema().model_json_schema()

```

```output
{&#x27;description&#x27;: &#x27;Update list of favorite pets&#x27;,
 &#x27;properties&#x27;: {&#x27;pets&#x27;: {&#x27;description&#x27;: &#x27;List of favorite pets to set.&#x27;,
   &#x27;items&#x27;: {&#x27;type&#x27;: &#x27;string&#x27;},
   &#x27;title&#x27;: &#x27;Pets&#x27;,
   &#x27;type&#x27;: &#x27;array&#x27;},
  &#x27;user_id&#x27;: {&#x27;description&#x27;: "User&#x27;s ID.",
   &#x27;title&#x27;: &#x27;User Id&#x27;,
   &#x27;type&#x27;: &#x27;string&#x27;}},
 &#x27;required&#x27;: [&#x27;pets&#x27;, &#x27;user_id&#x27;],
 &#x27;title&#x27;: &#x27;UpdateFavoritePetsSchema&#x27;,
 &#x27;type&#x27;: &#x27;object&#x27;}

```

```python
UpdateFavoritePets().tool_call_schema.model_json_schema()

```

```output
{&#x27;description&#x27;: &#x27;Update list of favorite pets&#x27;,
 &#x27;properties&#x27;: {&#x27;pets&#x27;: {&#x27;description&#x27;: &#x27;List of favorite pets to set.&#x27;,
   &#x27;items&#x27;: {&#x27;type&#x27;: &#x27;string&#x27;},
   &#x27;title&#x27;: &#x27;Pets&#x27;,
   &#x27;type&#x27;: &#x27;array&#x27;}},
 &#x27;required&#x27;: [&#x27;pets&#x27;],
 &#x27;title&#x27;: &#x27;update_favorite_pets&#x27;,
 &#x27;type&#x27;: &#x27;object&#x27;}

```

```python
class UpdateFavoritePets2(BaseTool):
    name: str = "update_favorite_pets"
    description: str = "Update list of favorite pets"

    def _run(self, pets: List[str], user_id: Annotated[str, InjectedToolArg]) -> None:
        user_to_pets[user_id] = pets

UpdateFavoritePets2().get_input_schema().model_json_schema()

```

```output
{&#x27;description&#x27;: &#x27;Use the tool.\n\nAdd run_manager: Optional[CallbackManagerForToolRun] = None\nto child implementations to enable tracing.&#x27;,
 &#x27;properties&#x27;: {&#x27;pets&#x27;: {&#x27;items&#x27;: {&#x27;type&#x27;: &#x27;string&#x27;},
   &#x27;title&#x27;: &#x27;Pets&#x27;,
   &#x27;type&#x27;: &#x27;array&#x27;},
  &#x27;user_id&#x27;: {&#x27;title&#x27;: &#x27;User Id&#x27;, &#x27;type&#x27;: &#x27;string&#x27;}},
 &#x27;required&#x27;: [&#x27;pets&#x27;, &#x27;user_id&#x27;],
 &#x27;title&#x27;: &#x27;update_favorite_petsSchema&#x27;,
 &#x27;type&#x27;: &#x27;object&#x27;}

```

```python
UpdateFavoritePets2().tool_call_schema.model_json_schema()

```

```output
{&#x27;description&#x27;: &#x27;Update list of favorite pets&#x27;,
 &#x27;properties&#x27;: {&#x27;pets&#x27;: {&#x27;items&#x27;: {&#x27;type&#x27;: &#x27;string&#x27;},
   &#x27;title&#x27;: &#x27;Pets&#x27;,
   &#x27;type&#x27;: &#x27;array&#x27;}},
 &#x27;required&#x27;: [&#x27;pets&#x27;],
 &#x27;title&#x27;: &#x27;update_favorite_pets&#x27;,
 &#x27;type&#x27;: &#x27;object&#x27;}

```[Edit this page](https://github.com/langchain-ai/langchain/edit/master/docs/docs/how_to/tool_runtime.ipynb)[Hiding arguments from the model](#hiding-arguments-from-the-model)
- [Injecting arguments at runtime](#injecting-arguments-at-runtime)
- [Other ways of annotating args](#other-ways-of-annotating-args)

Community

- [LangChain Forum](https://forum.langchain.com/)
- [Twitter](https://twitter.com/LangChainAI)
- [Slack](https://www.langchain.com/join-community)

GitHub

- [Organization](https://github.com/langchain-ai)
- [Python](https://github.com/langchain-ai/langchain)
- [JS/TS](https://github.com/langchain-ai/langchainjs)

More

- [Homepage](https://langchain.com)
- [Blog](https://blog.langchain.dev)
- [YouTube](https://www.youtube.com/@LangChain)

Copyright Â© 2025 LangChain, Inc.